<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/gaearon/babel-plugin-react-transform#readme"

    >babel-plugin-react-transform (v2.0.2)</a>
</h1>
<h4>Babel plugin to instrument React components with custom transforms</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.babel-plugin-react-transform">module babel-plugin-react-transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.babel-plugin-react-transform.default">
            function <span class="apidocSignatureSpan">babel-plugin-react-transform.</span>default
            <span class="apidocSignatureSpan">(_ref)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.babel-plugin-react-transform" id="apidoc.module.babel-plugin-react-transform">module babel-plugin-react-transform</a></h1>


    <h2>
        <a href="#apidoc.element.babel-plugin-react-transform.default" id="apidoc.element.babel-plugin-react-transform.default">
        function <span class="apidocSignatureSpan">babel-plugin-react-transform.</span>default
        <span class="apidocSignatureSpan">(_ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (_ref) {
  var t = _ref.types;
  var template = _ref.template;

  function matchesPatterns(path, patterns) {
    return !!(0, _find2.default)(patterns, function (pattern) {
      return t.isIdentifier(path.node, { name: pattern }) || path.matchesPattern(pattern);
    });
  }

  function isReactLikeClass(node) {
    return !!(0, _find2.default)(node.body.body, function (classMember) {
      return t.isClassMethod(classMember) &#x26;&#x26; t.isIdentifier(classMember.key, { name: &#x27;render&#x27; });
    });
  }

  function isReactLikeComponentObject(node) {
    return t.isObjectExpression(node) &#x26;&#x26; !!(0, _find2.default)(node.properties, function (objectMember) {
      return (t.isObjectProperty(objectMember) || t.isObjectMethod(objectMember)) &#x26;&#x26; (t.isIdentifier(objectMember.key, { name: &#x27;
render&#x27; }) || t.isStringLiteral(objectMember.key, { value: &#x27;render&#x27; }));
    });
  }

  // `foo({ displayName: &#x27;NAME&#x27; });` =&#x3e; &#x27;NAME&#x27;
  function getDisplayName(node) {
    var property = (0, _find2.default)(node.arguments[0].properties, function (node) {
      return node.key.name === &#x27;displayName&#x27;;
    });
    return property &#x26;&#x26; property.value.value;
  }

  function hasParentFunction(path) {
    return !!path.findParent(function (parentPath) {
      return parentPath.isFunction();
    });
  }

  // wrapperFunction(&#x22;componentId&#x22;)(node)
  function wrapComponent(node, componentId, wrapperFunctionId) {
    return t.callExpression(t.callExpression(wrapperFunctionId, [t.stringLiteral(componentId)]), [node]);
  }

  // `{ name: foo }` =&#x3e; Node { type: &#x22;ObjectExpression&#x22;, properties: [...] }
  function toObjectExpression(object) {
    var properties = Object.keys(object).map(function (key) {
      return t.objectProperty(t.identifier(key), object[key]);
    });

    return t.objectExpression(properties);
  }

  var wrapperFunctionTemplate = template(&#x27;\n    function WRAPPER_FUNCTION_ID(ID_PARAM) {\n      return function(COMPONENT_PARAM) {\n        return EXPRESSION;\n      };\n    }\n  &#x27;);

  var VISITED_KEY = &#x27;react-transform-&#x27; + Date.now();

  var componentVisitor = {
    Class: function Class(path) {
      if (path.node[VISITED_KEY] || !matchesPatterns(path.get(&#x27;superClass&#x27;), this.superClasses) || !isReactLikeClass(path.node)) {
        return;
      }

      path.node[VISITED_KEY] = true;

      var componentName = path.node.id &#x26;&#x26; path.node.id.name || null;
      var componentId = componentName || path.scope.generateUid(&#x27;component&#x27;);
      var isInFunction = hasParentFunction(path);

      this.components.push({
        id: componentId,
        name: componentName,
        isInFunction: isInFunction
      });

      // Can&#x27;t wrap ClassDeclarations
      var isStatement = t.isStatement(path.node);
      var expression = t.toExpression(path.node);

      // wrapperFunction(&#x22;componentId&#x22;)(node)
      var wrapped = wrapComponent(expression, componentId, this.wrapperFunctionId);
      var constId = void 0;

      if (isStatement) {
        // wrapperFunction(&#x22;componentId&#x22;)(class Foo ...) =&#x3e; const Foo = wrapperFunction(&#x22;componentId&#x22;)(class Foo ...)
        constId = t.identifier(componentName || componentId);
        wrapped = t.variableDeclaration(&#x27;const&#x27;, [t.variableDeclarator(constId, wrapped)]);
      }

      if (t.isExportDefaultDeclaration(path.parent)) {
        path.parentPath.insertBefore(wrapped);
        path.parent.declaration = constId;
      } else {
        path.replaceWith(wrapped);
      }
    },
    CallExpression: function CallExpression(path) {
      if (path.node[VISITED_KEY] || !matchesPatterns(path.get(&#x27;callee&#x27;), this.factoryMethods) || !isReactLikeComponentObject(path
.node.arguments[0])) {
        return;
      }

      path.node[VISITED_KEY] = true;

      // `foo({ displayName: &#x27;NAME&#x27; });` =&#x3e; &#x27;NAME&#x27;
      var componentName = getDisplayName(path.node);
      var componentId = componentName || path.scope.generateUid(&#x27;component&#x27;);
      var isInFunction = hasParentFunction(path);

      this.components.push({
        id: componentId,
        name: componentName,
        isInFunction: isInFunction
      });

      path.replaceWith(wrapC ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
